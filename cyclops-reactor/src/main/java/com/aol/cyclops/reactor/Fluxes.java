package com.aol.cyclops.reactor;

import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.Random;
import java.util.function.BiFunction;
import java.util.function.BiPredicate;
import java.util.function.BinaryOperator;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.stream.Collector;
import java.util.stream.Collectors;

import org.jooq.lambda.tuple.Tuple;
import org.jooq.lambda.tuple.Tuple2;
import org.reactivestreams.Publisher;

import com.aol.cyclops.Monoid;
import com.aol.cyclops.control.AnyM;
import com.aol.cyclops.control.For;
import com.aol.cyclops.control.Matchable;
import com.aol.cyclops.control.Matchable.CheckValue1;
import com.aol.cyclops.control.Publishers;
import com.aol.cyclops.control.ReactiveSeq;
import com.aol.cyclops.control.Trampoline;
import com.aol.cyclops.data.collections.extensions.standard.ListX;
import com.aol.cyclops.reactor.operators.GroupedWhile;
import com.aol.cyclops.types.anyM.AnyMSeq;
import com.aol.cyclops.types.stream.reactive.SeqSubscriber;
import com.aol.cyclops.util.function.QuadFunction;
import com.aol.cyclops.util.function.TriFunction;

import reactor.core.publisher.Flux;

/**
 * Companion class for working with Reactor Flux types
 * 
 * @author johnmcclean
 *
 */
public class Fluxes {
    
    /**
     * Construct an AnyM type from a Flux. This allows the Flux to be manipulated according to a standard interface
     * along with a vast array of other Java Monad implementations
     * 
     * <pre>
     * {@code 
     *    
     *    AnyMSeq<Integer> flux = Fluxes.anyM(Flux.just(1,2,3));
     *    AnyMSeq<Integer> transformedFlux = myGenericOperation(flux);
     *    
     *    public AnyMSeq<Integer> myGenericOperation(AnyMSeq<Integer> monad);
     * }
     * </pre>
     * 
     * @param flux To wrap inside an AnyM
     * @return AnyMSeq wrapping a flux
     */
    public static <T> AnyMSeq<T> anyM(Flux<T> flux) {
        return AnyM.ofSeq(flux);
    }
    /**
     * Perform a For Comprehension over a Flux, accepting 3 generating functions. 
     * This results in a four level nested internal iteration over the provided Publishers.
     * 
     *  <pre>
      * {@code
      *    
      *   import static com.aol.cyclops.reactor.Fluxes.forEach;
      *    
          forEach(Flux.range(1,10), 
                  a-> ReactiveSeq.iterate(a,i->i+1).limit(10),
                  (a,b) -> Maybe.<Integer>of(a+b),
                  (a,b,c) -> Mono.<Integer>just(a+b+c),
                  Tuple::tuple)
     * 
     * }
     * </pre>
     * 
     * @param value1 top level Flux
     * @param value2 Nested publisher
     * @param value3 Nested publisher
     * @param value4 Nested publisher
     * @param yieldingFunction  Generates a result per combination
     * @return Flux with an element per combination of nested publishers generated by the yielding function
     */
    public static <T1, T2, T3, R1, R2, R3, R> Flux<R> forEach(Flux<? extends T1> value1,
            Function<? super T1, ? extends Publisher<R1>> value2,
            BiFunction<? super T1, ? super R1, ? extends Publisher<R2>> value3,
            TriFunction<? super T1, ? super R1, ? super R2, ? extends Publisher<R3>> value4,
            QuadFunction<? super T1, ? super R1, ? super R2, ? super R3, ? extends R> yieldingFunction) {

        return AnyM.ofSeq(For.anyM(anyM(value1))
                             .anyM(a -> Publishers.anyM(value2.apply(a)))
                             .anyM(a -> b -> Publishers.anyM(value3.apply(a, b)))
                             .anyM(a -> b -> c -> Publishers.anyM(value4.apply(a, b, c)))
                             .yield4(yieldingFunction)
                             .unwrap())
                   .unwrap();

    }

    /**
     * Perform a For Comprehension over a Flux, accepting 3 generating functions. 
     * This results in a four level nested internal iteration over the provided Publishers. 
     * <pre>
     * {@code
     * 
     *  import static com.aol.cyclops.reactor.Fluxes.forEach;
     *   
     *  forEach(Flux.range(1,10), 
                            a-> ReactiveSeq.iterate(a,i->i+1).limit(10),
                            (a,b) -> Maybe.<Integer>of(a+b),
                            (a,b,c) -> Mono.<Integer>just(a+b+c),
                            (a,b,c,d) -> a+b+c+d <100,
                            Tuple::tuple);
     * 
     * }
     * </pre>
     * 
     * @param value1 top level Flux
     * @param value2 Nested publisher
     * @param value3 Nested publisher
     * @param value4 Nested publisher
     * @param filterFunction A filtering function, keeps values where the predicate holds
     * @param yieldingFunction Generates a result per combination
     * @return Flux with an element per combination of nested publishers generated by the yielding function
     */
    public static <T1, T2, T3, R1, R2, R3, R> Flux<R> forEach(Flux<? extends T1> value1,
            Function<? super T1, ? extends Publisher<R1>> value2,
            BiFunction<? super T1, ? super R1, ? extends Publisher<R2>> value3,
            TriFunction<? super T1, ? super R1, ? super R2, ? extends Publisher<R3>> value4,
            QuadFunction<? super T1, ? super R1, ? super R2, ? super R3, Boolean> filterFunction,
            QuadFunction<? super T1, ? super R1, ? super R2, ? super R3, ? extends R> yieldingFunction) {

        return AnyM.ofSeq(For.anyM(anyM(value1))
                             .anyM(a -> Publishers.anyM(value2.apply(a)))
                             .anyM(a -> b -> Publishers.anyM(value3.apply(a, b)))
                             .anyM(a -> b -> c -> Publishers.anyM(value4.apply(a, b, c)))
                             .filter(a -> b -> c -> d -> filterFunction.apply(a, b, c, d))
                             .yield4(yieldingFunction)
                             .unwrap())
                   .unwrap();

    }

    /**
     * Perform a For Comprehension over a Flux, accepting 2 generating functions. 
     * This results in a three level nested internal iteration over the provided Publishers. 
     * 
     * <pre>
     * {@code 
     * 
     * import static com.aol.cyclops.reactor.Fluxes.forEach;
     * 
     * forEach(Flux.range(1,10), 
                            a-> ReactiveSeq.iterate(a,i->i+1).limit(10),
                            (a,b) -> Maybe.<Integer>of(a+b),
                            Tuple::tuple);
     * 
     * }
     * </pre>
     * 
     * 
     * @param value1 top level Flux
     * @param value2 Nested publisher
     * @param value3 Nested publisher
     * @param yieldingFunction Generates a result per combination
     * @return Flux with an element per combination of nested publishers generated by the yielding function
     */
    public static <T1, T2, R1, R2, R> Flux<R> forEach(Flux<? extends T1> value1,
            Function<? super T1, ? extends Publisher<R1>> value2,
            BiFunction<? super T1, ? super R1, ? extends Publisher<R2>> value3,
            TriFunction<? super T1, ? super R1, ? super R2, ? extends R> yieldingFunction) {

        return AnyM.ofSeq(For.anyM(anyM(value1))
                             .anyM(a -> Publishers.anyM(value2.apply(a)))
                             .anyM(a -> b -> Publishers.anyM(value3.apply(a, b)))
                             .yield3(yieldingFunction)
                             .unwrap())
                   .unwrap();

    }

    /**
     * Perform a For Comprehension over a Flux, accepting 2 generating functions. 
     * This results in a three level nested internal iteration over the provided Publishers. 
     * <pre>
     * {@code 
     * 
     * import static com.aol.cyclops.reactor.Fluxes.forEach;
     * 
     * forEach(Flux.range(1,10), 
                   a-> ReactiveSeq.iterate(a,i->i+1).limit(10),
                   (a,b) -> Maybe.<Integer>of(a+b),
                   (a,b,c) ->a+b+c<10,
                   Tuple::tuple).toListX();
     * }
     * </pre>
     * 
     * @param value1 top level Flux
     * @param value2 Nested publisher
     * @param value3 Nested publisher
     * @param filterFunction A filtering function, keeps values where the predicate holds
     * @param yieldingFunction Generates a result per combination
     * @return
     */
    public static <T1, T2, R1, R2, R> Flux<R> forEach(Flux<? extends T1> value1,
            Function<? super T1, ? extends Publisher<R1>> value2,
            BiFunction<? super T1, ? super R1, ? extends Publisher<R2>> value3,
            TriFunction<? super T1, ? super R1, ? super R2, Boolean> filterFunction,
            TriFunction<? super T1, ? super R1, ? super R2, ? extends R> yieldingFunction) {

        return AnyM.ofSeq(For.anyM(anyM(value1))
                             .anyM(a -> Publishers.anyM(value2.apply(a)))
                             .anyM(a -> b -> Publishers.anyM(value3.apply(a, b)))
                             .filter(a -> b -> c -> filterFunction.apply(a, b, c))
                             .yield3(yieldingFunction)
                             .unwrap())
                   .unwrap();

    }

    /**
     * Perform a For Comprehension over a Flux, accepting an additonal generating function. 
     * This results in a two level nested internal iteration over the provided Publishers. 
     * 
     * <pre>
     * {@code 
     * 
     *  import static com.aol.cyclops.reactor.Fluxes.forEach;
     *  forEach(Flux.range(1, 10), i -> Flux.range(i, 10), Tuple::tuple)
              .subscribe(System.out::println);
              
       //(1, 1)
         (1, 2)
         (1, 3)
         (1, 4)
         ...
     * 
     * }</pre>
     * 
     * @param value1 top level Flux
     * @param value2 Nested publisher
     * @param yieldingFunction Generates a result per combination
     * @return
     */
    public static <T, R1, R> Flux<R> forEach(Flux<? extends T> value1, Function<? super T, Publisher<R1>> value2,
            BiFunction<? super T, ? super R1, ? extends R> yieldingFunction) {

        return AnyM.ofSeq(For.anyM(anyM(value1))
                             .anyM(a -> Publishers.anyM(value2.apply(a)))
                             .yield2(yieldingFunction)
                             .unwrap())
                   .unwrap();

    }

    /**
     * 
     * <pre>
     * {@code 
     * 
     *   import static com.aol.cyclops.reactor.Fluxes.forEach;
     * 
     *   forEach(Flux.range(1, 10), i -> Flux.range(i, 10),(a,b) -> a>2 && b<10,Tuple::tuple)
               .subscribe(System.out::println);
               
       //(3, 3)
         (3, 4)
         (3, 5)
         (3, 6)
         (3, 7)
         (3, 8)
         (3, 9)
         ...
     
     * 
     * }</pre>
     * 
     * 
     * @param value1 top level Flux
     * @param value2 Nested publisher
     * @param filterFunction A filtering function, keeps values where the predicate holds
     * @param yieldingFunction Generates a result per combination
     * @return
     */
    public static <T, R1, R> Flux<R> forEach(Flux<? extends T> value1, Function<? super T, ? extends Publisher<R1>> value2,
            BiFunction<? super T, ? super R1, Boolean> filterFunction,
            BiFunction<? super T, ? super R1, ? extends R> yieldingFunction) {

        return AnyM.ofSeq(For.anyM(anyM(value1))
                             .anyM(a -> Publishers.anyM(value2.apply(a)))
                             .filter(a -> b -> filterFunction.apply(a, b))
                             .yield2(yieldingFunction)
                             .unwrap())
                   .unwrap();

    }
    
    /**
     * Batch elements in a Flux by size into a collection created by the
     * supplied factory
     * 
     * <pre>
     * {@code
     * FluxUtils.grouped(Flux.just(1,2,3,1,1,1),3,()->new TreeSet<>())
     * 
     * //Flux[Set[1,2,4],Set[1]]

     * }
     * </pre>
     * 
     * @param stream Flux to group
     * @param groupSize Size of each batch
     * @param factory A supplier used to create the colleciton used to store groups
     * @return Grouped Flux
     */
    public final static <T, C extends Collection<? super T>> Flux<C> grouped(final Flux<T> stream, final int groupSize,
            final Supplier<C> factory) {
        
        return Flux.fromIterable(()-> new Iterator<C>(){
            
            Iterator<C> it;
            private void init(){
                if(it==null){
                    ReactiveSeq<T> seq = ReactiveSeq.fromPublisher(stream);
                    it = seq.grouped(groupSize,factory).iterator();
                }
            }
            @Override
            public boolean hasNext() {
                init();
                return it.hasNext();
            }

            @Override
            public C next() {
                init();
                return it.next();
            }
               
           }
         );

    }
    
    
    /**
     * Get a lazy iterator over the data in a Flux
     * 
     * @param stream Flux to get iterator for
     * @return Iterator over data in the supplied Flux
     */
    public static <T> Iterator<T> iterator(Flux<T> stream){
        SeqSubscriber<T> sub = SeqSubscriber.subscriber();
        Iterator<T> it = stream.subscribeWith(sub).iterator();
        return it;
    }
    
    /**
     * Combine adjacent elements within a Flux for as long as the supplied predicate holds.
     *  
     * This is a stateful grouping & reduction operation. The output of a combination may in turn be combined
     * with it's neighbour
     * <pre>
     * {@code 
     *  FluxUtils.combine(Flux.just(1,1,2,3),(a, b)->a.equals(b),Semigroups.intSum)
                   
                   
     *  //Flux(3,4) 
     * }</pre>
     * 
     * @param stream Flux to combine elements
     * @param predicate Determines if subsequent element should be combine
     * @param op Combiner function
     * @return Flux with partial reduction of internal elements by combiner where predicate holds
     */
    public static <T> Flux<T> combine(final Flux<T> stream, final BiPredicate<? super T, ? super T> predicate, final BinaryOperator<T> op) {
       
        final Iterator<T> it = iterator(stream);
        final Object UNSET = new Object();
        return Flux.fromIterable(()->new Iterator<ReactiveSeq<T>>() {
            T current = (T) UNSET;

            @Override
            public boolean hasNext() {
                return it.hasNext() || current != UNSET;
            }

            @Override
            public ReactiveSeq<T> next() {
                while (it.hasNext()) {
                    final T next = it.next();

                    if (current == UNSET) {
                        current = next;

                    } else if (predicate.test(current, next)) {
                        current = op.apply(current, next);

                    } else {
                        final T result = current;
                        current = (T) UNSET;
                        return ReactiveSeq.of(result, next);
                    }
                }
                if (it.hasNext())
                    return ReactiveSeq.empty();
                final T result = current;
                current = (T) UNSET;
                return ReactiveSeq.of(result);
            }

        }).flatMap(Function.identity());
    }
    
    /**
     * Convert to a Flux with the result of a reduction operation repeated
     * specified times
     * 
     * <pre>
     * {@code 
     *   List<Integer> list = Fluexs.cycle(Flux.just(1,2,2)),Reducers.toCountInt(),3)
     *                                 .collect(Collectors.toList());
     *   //List[3,3,3];
     *   }
     * </pre>
     * 
     * @param stream Flux to cycle
     * @param m Monoid to be used in reduction
     * @param times number of times to cycle
     * @return Stream with reduced values repeated
     */
    public final static <T> Flux<T> cycle(final Flux<T> stream,Monoid<T> m, int times){
        return Flux.fromIterable(()-> new Iterator<T>(){
            
            Iterator<T> it;
            private void init(){
                if(it==null){
                    ReactiveSeq<T> seq = ReactiveSeq.fromPublisher(stream);
                    it = seq.cycle(m, times).iterator();
                }
            }
            @Override
            public boolean hasNext() {
                init();
                return it.hasNext();
            }

            @Override
            public T next() {
                init();
                return it.next();
            }
               
           }
         );
    }
    /**
     * Repeat in a Flux while specified predicate holds
     * <pre>
     * {@code 
     *  int count =0;
     *  
        assertThat(FluxUtils.cycleWhile(Flux.just(1,2,2)
                                            ,next -> count++<6 )
                                            .collect(Collectors.toList()),equalTo(Arrays.asList(1,2,2,1,2,2)));
     * }
     * </pre>
     * @param predicate
     *            repeat while true
     * @return Repeating Stream
     */
    public final static <T> Flux<T> cycleWhile(final Flux<T> stream, final Predicate<? super T> predicate) {
        return Flux.fromIterable(()-> new Iterator<T>(){
            
            Iterator<T> it;
            private void init(){
                if(it==null){
                    ReactiveSeq<T> seq = ReactiveSeq.fromPublisher(stream);
                    it = seq.cycleWhile(predicate).iterator();
                }
            }
            @Override
            public boolean hasNext() {
                init();
                return it.hasNext();
            }

            @Override
            public T next() {
                init();
                return it.next();
            }
               
           }
         );
    }
    public final static <T> Flux<T> takeUntil(final Flux<T> stream, final Predicate<? super T> predicate) {
        return Flux.fromIterable(()-> new Iterator<T>(){
            
            Iterator<T> it;
            private void init(){
                if(it==null){
                    ReactiveSeq<T> seq = ReactiveSeq.fromPublisher(stream);
                    it = seq.takeUntil(predicate).iterator();
                }
            }
            @Override
            public boolean hasNext() {
                init();
                return it.hasNext();
            }

            @Override
            public T next() {
                init();
                return it.next();
            }
               
           }
         );
    }
    public final static <T> Flux<T> limitUntil(final Flux<T> stream, final Predicate<? super T> predicate) {
        return Flux.fromIterable(()-> new Iterator<T>(){
            
            Iterator<T> it;
            private void init(){
                if(it==null){
                    ReactiveSeq<T> seq = ReactiveSeq.fromPublisher(stream);
                    it = seq.limitUntil(predicate).iterator();
                }
            }
            @Override
            public boolean hasNext() {
                init();
                return it.hasNext();
            }

            @Override
            public T next() {
                init();
                return it.next();
            }
               
           }
         );
    }

    /**
     * Repeat in a Stream until specified predicate holds
     * 
     * <pre>
     * {@code 
     *  count =0;
        assertThat(FluxUtils.cycleUntil(Flux.just(1,2,2,3)
                                            ,next -> count++>10 )
                                            .collect(Collectors.toList()),equalTo(Arrays.asList(1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2)));
    
     * }
     * </pre>
     * @param predicate
     *            repeat while true
     * @return Repeating Stream
     */
    public final static <T> Flux<T> cycleUntil(final Flux<T> stream, final Predicate<? super T> predicate) {
        return Flux.fromIterable(()-> new Iterator<T>(){
            
            Iterator<T> it;
            private void init(){
                if(it==null){
                    ReactiveSeq<T> seq = ReactiveSeq.fromPublisher(stream);
                    it = seq.cycleUntil(predicate).iterator();
                }
            }
            @Override
            public boolean hasNext() {
                init();
                return it.hasNext();
            }

            @Override
            public T next() {
                init();
                return it.next();
            }
               
           }
         );
    }
    
    /**
     * Keep only those elements in a stream that are of a given type.
     * 
     * 
     * assertThat(Arrays.asList(1, 2, 3), 
     *      equalTo( FluxUtils.ofType(Flux.just(1, "a", 2, "b", 3,Integer.class));
     * 
     */
    @SuppressWarnings("unchecked")
    public static <T, U> Flux<U> ofType(final Flux<T> stream, final Class<? extends U> type) {
        return stream.filter(type::isInstance)
                     .map(t -> (U) t);
    }
    
    public final static <T> Flux<ListX<T>> groupedWhile(final Flux<T> stream, final Predicate<? super T> predicate) {
        return new GroupedWhile<T, ListX<T>>(
                                                   stream).batchWhile(predicate);
    }

    public final static <T, C extends Collection<? super T>> Flux<C> groupedWhile(final Flux<T> stream, final Predicate<? super T> predicate,
            final Supplier<C> factory) {
        return new GroupedWhile<T, C>(
                                            stream, factory).batchWhile(predicate);
    }

    public final static <T> Flux<ListX<T>> groupedUntil(final Flux<T> stream, final Predicate<? super T> predicate) {
        return groupedWhile(stream, predicate.negate());
    }
    
    
    /**
     * Performs a map operation that can call a recursive method without running out of stack space
     * <pre>
     * {@code
     * 
       FluxUtils.trampoline(Flux.just(10,20,30,40),i-> fibonacci(i))
                .forEach(System.out::println); 
                
       Trampoline<Long> fibonacci(int i){
           return fibonacci(i,1,0);
       }
       Trampoline<Long> fibonacci(int n, long a, long b) {
           return n == 0 ? Trampoline.done(b) : Trampoline.more( ()->fibonacci(n-1, a+b, a));
       }        
                
     * 55
       6765
       832040
       102334155
     * 
     * 
     * 
       FluxUtils.trampoline(Flux.just(10_000,200_000,3_000_000,40_000_000),i-> fibonacci(i))
                .forEach(System.out::println);
                
                
     * completes successfully
     * }
     * </pre>
     * 
    * @param mapper TCO Transformation function
    * @return Functor transformed by the supplied transformation function
    */
   public static <T,R> Flux<R> trampoline(Flux<T> flux,Function<? super T, ? extends Trampoline<? extends R>> mapper) {
       return flux.map(in -> mapper.apply(in)
                              .result());
   }

   /**
   * Transform the elements of this Stream with a Pattern Matching case and default value
   *
   * <pre>
   * {@code
   * List<String> result = CollectionX.of(1,2,3,4)
                                            .patternMatch(
                                                      c->c.valuesWhere(i->"even", (Integer i)->i%2==0 )
                                                    )
   * }
   * // CollectionX["odd","even","odd","even"]
   * </pre>
   *
   *
   * @param case1 Function to generate a case (or chain of cases as a single case)
   * @param otherwise Value if supplied case doesn't match
   * @return CollectionX where elements are transformed by pattern matching
   */
   public static <T,R> Flux<R> patternMatch(Flux<T> flux,Function<CheckValue1<T, R>, CheckValue1<T, R>> case1, Supplier<? extends R> otherwise) {

       return flux.map(u -> Matchable.of(u)
                                .matches(case1, otherwise)
                                .get());

   }
   
   
   public static <T> Flux<T> reverse(Flux<T> flux){
       
      
       return Flux.fromIterable(()-> new Iterator<T>(){
        
        Iterator<T> it;
        private void init(){
            if(it==null){
                List<T> list = flux.collect(Collectors.toList()).block();
                ReactiveSeq<T> seq = ReactiveSeq.fromList(list).reverse();
                it = seq.iterator();
            }
        }
        @Override
        public boolean hasNext() {
            init();
            return it.hasNext();
        }

        @Override
        public T next() {
            init();
            return it.next();
        }
           
       }
     );
   }
   public static <T> Flux<T> shuffle(Flux<T> flux){
       
       
       return Flux.fromIterable(()-> new Iterator<T>(){
        
        Iterator<T> it;
        private void init(){
            if(it==null){
                List<T> list = flux.collect(Collectors.toList()).block();
                Collections.shuffle(list);
               
                it = list.iterator();
            }
        }
        @Override
        public boolean hasNext() {
            init();
            return it.hasNext();
        }

        @Override
        public T next() {
            init();
            return it.next();
        }
           
       }
     );
   }
   public static <T> Flux<T> shuffle(Flux<T> flux,Random random){
       
       
       return Flux.fromIterable(()-> new Iterator<T>(){
        
        Iterator<T> it;
        private void init(){
            if(it==null){
                List<T> list = flux.collect(Collectors.toList()).block();
                Collections.shuffle(list,random);
               
                it = list.iterator();
            }
        }
        @Override
        public boolean hasNext() {
            init();
            return it.hasNext();
        }

        @Override
        public T next() {
            init();
            return it.next();
        }
           
       }
     );
   }
   public static <T> Flux<T> sorted(Flux<T> flux){
       
       
       return Flux.fromIterable(()-> new Iterator<T>(){
        
        Iterator<T> it;
        private void init(){
            if(it==null){
                ReactiveSeq<T> seq = ReactiveSeq.fromPublisher(flux);
                it = seq.sorted().iterator();
            }
        }
        @Override
        public boolean hasNext() {
            init();
            return it.hasNext();
        }

        @Override
        public T next() {
            init();
            return it.next();
        }
           
       }
     );
   }

    public static <T> Flux<T> onEmpty(Flux<T> flux, T value) {
        return Flux.fromIterable(() -> new Iterator<T>() {

            Iterator<T> it;

            private void init() {
                if (it == null) {
                    ReactiveSeq<T> seq = ReactiveSeq.fromPublisher(flux);
                    it = seq.onEmpty(value)
                            .iterator();
                }
            }

            @Override
            public boolean hasNext() {
                init();
                return it.hasNext();
            }

            @Override
            public T next() {
                init();
                return it.next();
            }

        });
    }
    public static <T> Flux<T> onEmptySwitch(Flux<T> flux, Supplier<? extends Flux<T>> value) {
        return Flux.fromIterable(() -> new Iterator<T>() {

            Iterator<T> it;

            private void init() {
                if (it == null) {
                    ReactiveSeq<T> seq = ReactiveSeq.fromPublisher(flux);
                    it = seq.onEmptySwitch(()->ReactiveSeq.fromPublisher(value.get()))
                            .iterator();
                }
            }

            @Override
            public boolean hasNext() {
                init();
                return it.hasNext();
            }

            @Override
            public T next() {
                init();
                return it.next();
            }

        });
    }
    public static <T> Flux<T> onEmptyGet(Flux<T> flux, Supplier<? extends T> value) {
        return Flux.fromIterable(() -> new Iterator<T>() {

            Iterator<T> it;

            private void init() {
                if (it == null) {
                    ReactiveSeq<T> seq = ReactiveSeq.fromPublisher(flux);
                    it = seq.onEmptyGet(value)
                            .iterator();
                }
            }

            @Override
            public boolean hasNext() {
                init();
                return it.hasNext();
            }

            @Override
            public T next() {
                init();
                return it.next();
            }

        });
    }
    public static <T,X extends Throwable> Flux<T> onEmptyThrow(Flux<T> flux, Supplier<? extends X> value) {
        return Flux.fromIterable(() -> new Iterator<T>() {

            Iterator<T> it;

            private void init() {
                if (it == null) {
                    ReactiveSeq<T> seq = ReactiveSeq.fromPublisher(flux);
                    it = seq.onEmptyThrow(value)
                            .iterator();
                }
            }

            @Override
            public boolean hasNext() {
                init();
                return it.hasNext();
            }

            @Override
            public T next() {
                init();
                return it.next();
            }

        });
    }

   public static <T,U> Flux<T> sorted(Flux<T> flux,Function<? super T, ? extends U> function){
       
       return Flux.fromIterable(()-> new Iterator<T>(){
           
           Iterator<T> it;
           private void init(){
               if(it==null){
                   ReactiveSeq<T> seq = ReactiveSeq.fromPublisher(flux);
                   it = seq.sorted((Function)function).iterator();
               }
           }
           @Override
           public boolean hasNext() {
               init();
               return it.hasNext();
           }

           @Override
           public T next() {
               init();
               return it.next();
           }
              
          }
        );
   }
   public static <T> Flux<T> sorted(Flux<T> flux,Comparator<? super T> c){

       return Flux.fromIterable(()-> new Iterator<T>(){
        
        Iterator<T> it;
        private void init(){
            if(it==null){
                ReactiveSeq<T> seq = ReactiveSeq.fromPublisher(flux);
                it = seq.sorted(c).iterator();
            }
        }
        @Override
        public boolean hasNext() {
            init();
            return it.hasNext();
        }

        @Override
        public T next() {
            init();
            return it.next();
        }
           
       }
     );
   }
   public static <T,U> Flux<U> scanRight(Flux<T> flux, U identity, BiFunction<? super T, ? super U, ? extends U> combiner){

       return Flux.fromIterable(()-> new Iterator<U>(){
        
        Iterator<U> it;
        private void init(){
            if(it==null){
                ReactiveSeq<T> seq = ReactiveSeq.fromPublisher(flux);
                it = seq.scanRight(identity, combiner).iterator();
            }
        }
        @Override
        public boolean hasNext() {
            init();
            return it.hasNext();
        }

        @Override
        public U next() {
            init();
            return it.next();
        }
           
       }
     );
   }
   public static <T> Flux<T> scanRight(Flux<T> flux, Monoid<T> monoid){

       return Flux.fromIterable(()-> new Iterator<T>(){
        
        Iterator<T> it;
        private void init(){
            if(it==null){
                ReactiveSeq<T> seq = ReactiveSeq.fromPublisher(flux);
                it = seq.scanRight(monoid).iterator();
            }
        }
        @Override
        public boolean hasNext() {
            init();
            return it.hasNext();
        }

        @Override
        public T next() {
            init();
            return it.next();
        }
           
       }
     );
   }

   public static <T> Flux<T> removeAll(Flux<T> flux, Iterable<? extends T> iterable){
       return Flux.fromIterable(()-> new Iterator<T>(){
           
           Iterator<T> it;
           private void init(){
               if(it==null){
                   ReactiveSeq<T> seq = ReactiveSeq.fromPublisher(flux);
                   it = seq.removeAll(iterable).iterator();
               }
           }
           @Override
           public boolean hasNext() {
               init();
               return it.hasNext();
           }

           @Override
           public T next() {
               init();
               return it.next();
           }
              
          }
        );
   }
   public static <T> Flux<T> retainAll(Flux<T> flux, Iterable<? extends T> iterable){
       return Flux.fromIterable(()-> new Iterator<T>(){
           
           Iterator<T> it;
           private void init(){
               if(it==null){
                   ReactiveSeq<T> seq = ReactiveSeq.fromPublisher(flux);
                   it = seq.retainAll(iterable).iterator();
               }
           }
           @Override
           public boolean hasNext() {
               init();
               return it.hasNext();
           }

           @Override
           public T next() {
               init();
               return it.next();
           }
              
          }
        );
   }
   
   public static <T> Flux<T> intersperse(Flux<T> flux,T value){
       return Flux.fromIterable(()-> new Iterator<T>(){
           
           Iterator<T> it;
           private void init(){
               if(it==null){
                   ReactiveSeq<T> seq = ReactiveSeq.fromPublisher(flux);
                   it = seq.intersperse(value).iterator();
               }
           }
           @Override
           public boolean hasNext() {
               init();
               return it.hasNext();
           }

           @Override
           public T next() {
               init();
               return it.next();
           }
              
          }
        );
   }
   public static <T> Flux<ListX<T>> sliding(Flux<T> flux, int windowSize, int increment) {
       return Flux.fromIterable(()-> new Iterator<ListX<T>>(){
           
           Iterator<ListX<T>> it;
           private void init(){
               if(it==null){
                   ReactiveSeq<T> seq = ReactiveSeq.fromPublisher(flux);
                   it = seq.sliding(windowSize, increment).iterator();
               }
           }
           @Override
           public boolean hasNext() {
               init();
               return it.hasNext();
           }

           @Override
           public ListX<T> next() {
               init();
               return it.next();
           }
              
          }
        );
   }
      
   
   public static <T> Flux<ListX<T>> grouped(Flux<T> flux,int size){
       return Flux.fromIterable(()-> new Iterator<ListX<T>>(){
           
           Iterator<ListX<T>> it;
           private void init(){
               if(it==null){
                   ReactiveSeq<T> seq = ReactiveSeq.fromPublisher(flux);
                   it = seq.grouped(size).iterator();
               }
           }
           @Override
           public boolean hasNext() {
               init();
               return it.hasNext();
           }

           @Override
           public ListX<T> next() {
               init();
               return it.next();
           }
              
          }
        );
   }
   public static <T,K, A, D> Flux<Tuple2<K, D>> grouped(Flux<T> flux, Function<? super T, ? extends K> classifier, Collector<? super T, A, D> downstream){

       return Flux.fromIterable(()-> new Iterator<Tuple2<K, D>>(){
        
        Iterator<Tuple2<K, D>> it;
        private void init(){
            if(it==null){
                ReactiveSeq<T> seq = ReactiveSeq.fromPublisher(flux);
                
                it = (Iterator)seq.grouped(classifier,downstream).iterator();
            }
        }
        @Override
        public boolean hasNext() {
            init();
            return it.hasNext();
        }

        @Override
        public Tuple2<K, D> next() {
            init();
            return it.next();
        }
           
       }
     );
   }
 
   public static <T,K, A, D> Flux<Tuple2<K, D>> grouped(Flux<T> flux, Function<? super T, ? extends K> classifier){

       return Flux.fromIterable(()-> new Iterator<Tuple2<K, D>>(){
        
        Iterator<Tuple2<K, D>> it;
        private void init(){
            if(it==null){
                ReactiveSeq<T> seq = ReactiveSeq.fromPublisher(flux);
                it = (Iterator)seq.grouped(classifier).iterator();
            }
        }
        @Override
        public boolean hasNext() {
            init();
            return it.hasNext();
        }

        @Override
        public Tuple2<K, D> next() {
            init();
            return it.next();
        }
           
       }
     );
   }
   
   public  static <T> Flux<Tuple2<T, Long>> zipWithIndex(Flux<T> stream) {
       
       return stream.zipWith(ReactiveSeq.rangeLong(0,Long.MAX_VALUE),Tuple::tuple);
   }
   /**
    * Delete elements between given indexes in a Flux
    * <pre>
    * {@code 
    * List<String> result =    FluxUtils.deleteBetween(Flux.just(1,2,3,4,5,6),2,4)
                                           .map(it ->it+"!!")
                                           .collect(Collectors.toList())
                                           .block();
   
           assertThat(result,equalTo(Arrays.asList("1!!","2!!","5!!","6!!")));
    * }
    * </pre>
    * @param start index
    * @param end index
    * @return Stream with elements removed
    */
   public static final <T> Flux<T> deleteBetween(final Flux<T> stream, final int start, final int end) {
       return zipWithIndex(stream).filter(t->t.v2<start || t.v2>(end-1)).map(t->t.v1);
       
   }
   
  /**
   * Insert data into a Flux at given position
   * <pre>
   * {@code  
   * List<String> result =    FluxUtils.insertAt(Flux.just(1,2,3),1,100,200,300)
                                       .map(it ->it+"!!")
                                       .collect(Collectors.toList())
                                       .block();
  
          assertThat(result,equalTo(Arrays.asList("1!!","100!!","200!!","300!!","2!!","3!!")));
   * 
   * }
   * </pre>
   * @param pos to insert data at
   * @param values to insert
   * @return Stream with new data inserted
   */
  public static final <T> Flux<T> insertAt(final Flux<T> stream, final int pos, final T... values) {
      Flux<T> start = stream.take(pos);
      Flux<T> end = zipWithIndex(stream).skipWhile(t->t.v2<pos).map(t->t.v1);
      return start.concatWith(Flux.just(values)).concatWith(end);
      
  }

  public final static <T> Flux<ListX<T>> groupedStatefullyUntil(final Flux<T> flux,
          final BiPredicate<ListX<? super T>, ? super T> predicate) {
      return Flux.fromIterable(()-> new Iterator<ListX<T>>(){
          
          Iterator<ListX<T>> it;
          private void init(){
              if(it==null){
                  ReactiveSeq<T> seq = ReactiveSeq.fromPublisher(flux);
                  it = seq.groupedStatefullyUntil(predicate).iterator();
              }
          }
          @Override
          public boolean hasNext() {
              init();
              return it.hasNext();
          }

          @Override
          public ListX<T> next() {
              init();
              return it.next();
          }
             
         }
       );
    
  }


}

