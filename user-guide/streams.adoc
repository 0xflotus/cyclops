
[index]
  

== Working With Streams

Cyclops provides a lot of helpful classes and utilities to make working with streams of data a breeze. They are 

* StreamUtils : a large collection of static methods for manipulating JDK 8 Streams
* Streamable : an interface that represents a Stream that can replayed and has a large number of available Stream operations in it's own right
* SequenceM : an advanced sequential stream interface that extends that extends
java.util.stream.Stream<T>, org.jooq.lambda.Seq<T>, java.lang.Iterable<T>, org.reactivestreams.Publisher<T> and adds additional operators.

StreamUtils, Streamable and SequenceM share many operators, in general though SequenceM has the larest range of operators.

[IMPORTANT]
====
Some knowledge of the Java 8 Streams API is assumed here. SequenceM provides all of the Stream operations (by inheriting from Stream) and a lot more. The Oracle tutorial for Streams is a good place to start if you are brand new to this concept.
====


=== Introduction to StreamUtils

StreamUtils provides a large range of additional operators for standard Java 8 Streams, these include operators for batching & windowing, error handling and retrying, scheduling, asyncrhonous execution, zipping, controlling emissions by time, appending, deleting and rearranging Streams and more!

.Using StreamUtils with a standard Java Stream
====
In this example we will delete between element 2 and element 4
[source,java]
----
List<String> result = StreamUtils.deleteBetween(Stream.of(1,2,3,4,5,6),2,4)
                                .map(it ->it+"!!")
                                .collect(Collectors.toList());
                                
//"1!!","2!!","5!!","6!!"
----

====
[NOTE]
====
There is an equivalent StreamUtils class for Javaslang Streams.
====


=== Introduction to Streamable

Streamable is a class that represents something that can be Streamed
repeatedly, Streamable also has a large number of operators viewable via http://static.javadoc.io/com.aol.cyclops/cyclops-sequence-api/7.1.0/com/aol/cyclops/sequence/streamable/Streamable.html[javadoc]. 



Streamables can also be constructed lazily from Streams, or even in a
similar manner to Streams. E.g.

.Creating a Streamable
====
[source,java]
----
Streamable.fromStream(Stream.of(1,2,3));
Streamable.of(1,2,3);
Streamable.generate(()->"hello world"));
SequenceM.of(1,2,3).toStreamable();
----
====

And then converted to a Stream, SequenceM or even manipulated directly like a Stream

.Using a Streamable
====
[source,java]
----
SequenceM<Integer> seq = streamable.sequenceM();
Stream<Integer> stream = streable.stream();

//or even treat the streamable like a stream
Streamable<Integer> initial = Streamable.of(1,2,3);
Streamable<String> nextStage = initial.map(i->"hello"+i);
----
====

[IMPORTANT]
====
Streamable works by lazily constructing an intermediate collection that captures
the values that pass through each phase of the Stream, and as such is
not suitable for infinite or very large Streams. A Streamable can be
converted to a standard non-caching Stream at any stage, however, and
that should be the approach for any stages where you do not wish to
cache the data traveleling through. Streamable#toSequenceM() converts to
a non-caching Stream that also has a SequenceM#toStreamable() operator,
so switching between caching and non-caching contexts is
straightforward.
====

=== Introduction to SequenceM

SequenceM is a sequential Stream, it can be created in the same manner as standard JDK streams, but offers a large number of powerful additional operators.

.Creating a SequenceM
====
[source,java]
----
SequenceM.fromStream(Stream.of(1,2,3));
SequenceM.fromList(Arrays.list(1,2,3));
SequenceM.of(1,2,3);
SequenceM.generate(()->"hello world"));
----
====
[source,java]

=== HotStreams

[NOTE]
====
HotStreams are streams that are actively flowing. They can be created via the hotstream method on SequenceM or in StreamUtils. They execute on a single thread on a provided executor.
====
HotStreams are available for both SequenceM and standard JDK Streams via StreamUtils.

.Creating a HotStream
====

```java
Executor exec = Executors.newFixedThreadPool(1);
SequenceM.of(1,2,3)
	 .peek(v->v+1)
	 .peek(System.out::println)
	 .hotStream(exec);
```

In this example the Stream will start processing immediately on exec, and we will see 

2

3

4

printed out to the console.

For a JDK Stream we could rewrite the code above to

```java
Executor exec = Executors.newFixedThreadPool(1);
StreamUtils.hotStream(Stream.of(1,2,3)
	 .peek(v->v+1)
	 .peek(System.out::println)
	 ,exec);
```

====
==== Connecting to a HotStream

Once a HotStream has been created, users can connect to it via the connect operator. This returns another Stream that recieves values from the HotSteam. By default the connected Stream will be a standard 'cold' Stream. That is, the values will begin to accumulate in the transfer queue for the new Stream until a terminal operation is invoked for that Stream.

Multiple Streams can connect to a single HotStream.


.Connecting to a HotStream
====
[source,java]
----
In the example below 5,000 entries will be written out on the HotStreams executing thread, and 100 of those will also be written out on the current thread.
  
SequenceM.range(0,Integer.MAX_VALUE)
                    .limit(5000)
                    .peek(System.out::println)
                    .hotStream(exec)
                    .connect()
                    .limit(100)
                    .forEach(next->System.out.println("Current thread : " + next);
----
====
===== Data transfer between Streams

HotStreams use a (configurable) transfer queue to transfer data to client Streams.

image:https://cloud.githubusercontent.com/assets/9964792/12211387/7eee02ea-b658-11e5-8605-4e29116bc0f7.png[]

When the connect method is called a new Queue is created (by default an Agrona OneToOneConcurrentArrayQueue if non is provided by the user).

==== Back pressure
When two Streams have been joined it is possible that the producting Stream may produce data at a rate faster than the consuming queue can handle. Future versions of cyclops will offer tighter integration with simple-react, which has a number of strategies for dealing with scenario - but for now it is possible for the consuming Stream to signal back pressure by making use of a blocking queue as the transfer queue between the HotStream and the connected Stream.

[WARNING]
====
The default transfer queue used by the connect method on a HotStream is an Agrona wait-free, bounded OneToOneConcurrentArrayQueue. If this queue fills up due to a producer out performing the consumer then an illegal state exception will be thrown.
====
.Applying Back Pressure
====
----
In the example below 5,000 entries will be written out on the HotStreams executing thread, the consuming thread will only emit one per second. This will cause the transfer queue to fill up, and the SequenceM generating the HotStream will crash.
  
SequenceM.range(0,Integer.MAX_VALUE)
                    .limit(5000)
                    .peek(System.out::println)
                    .hotStream(exec)
                    .connect()
                    .onePer(1,TimeUnit.SECONDS)
                    .forEach(next->System.out.println("Current thread : " + next);
                    
                    
Instead we connect and use a BlockingStream as a transfer queue, the producing Stream will ultimately be slowed to the same rate as the consuming Stream. 

SequenceM.range(0,Integer.MAX_VALUE)
                    .limit(5000)
                    .peek(System.out::println)
                    .hotStream(exec)
                    .connect(new BlockingQueue(400))
                    .onePer(1,TimeUnit.SECONDS)
                    .forEach(next->System.out.println("Current thread : " + next);
----
====
=== reactive-streams
reactive-streams is an api for advanced inter-stream operability. Cyclops, when simple-react is added to the class path can provide both a reactive-streams publisher and subscriber.
==== Creating a Subscriber

SequenceM has a static subscriber method that returns a Cyclops reactive-streams Subscriber. That is a class that can subscribe to any reactive-streams publisher (e.g. an RxJava Observable, Pivotal REACTOR Stream, akka-stream etc).

CyclopsSubscriber has a single method sequenceM() that returns a SequenceM instance (remember that SequenceM extenads java.util.stream.Stream - so this also a standard, sequential Java 8 Stream).

.Creating a reactive-streams Subscriber
====
[source,java]
----
CyclopsSubscriber sub = SequenceM.subscriber();
sub.sequenceM().toList();

//[]

In this example our subscriber will be empty, as it has not attached to a publisher, so our generated List will also be empty.
----
====
SequenceM implements reactive-streams Publisher interface, and as such has the reactive-streams api publish method.

.Connecting a Subscriber to a Publisher
====
[source,java]
----
CyclopsSubscriber sub = SequenceM.subscriber();
SequenceM.of(1,2,3,4).publish(sub);
sub.sequenceM().toList();

//[1,2,3,4]

In this example our subscriber has connected to a publisher that will send the values 1,2,3,4 in sequence, on request.
----
====
=== Batching, Windowing and Sliding views

Cyclops provides a number of different batching and windowing operations, none of which terminate / fully consume the Stream (i.e. they are compatible with infinitely large Streams). The *Sliding* operator creates a sliding view whereas both batch & window operators return batches of elements and differ only by return type (batch - returns a List, window - returns a Streamable).

[NOTE]
====
jOOλ 0.9.9 provides a large range of windowing functions inspired by SQL windowing operations. The api and, crucially, behaviour is significantly different to the windowing functions in Cyclops (the jOOλ windowing functions consume the Stream) - as result the name of the cyclops windowing functions may change in future releases to disambiguate.
====

The current Batching / Windowing operations in cyclops are inspired by Reactive eXtensions rather than SQL. Like in Reactive eXtensions Batching (or Buffering) differs from Windowing only in terms of the supplied parameter type - a List for Batching and a Streamable for Windowing.

https://medium.com/@johnmcclean/reactive-programming-with-java-8-and-simple-react-batching-and-chunking-ecac62ce8bec#.ydm0n1jdc[Also see simple-react tutorial on batching]

image::https://cloud.githubusercontent.com/assets/9964792/6780846/80928004-d160-11e4-85b1-227f9c7652b6.png[]


==== Sliding

Sliding produces a sliding view over a Stream, there are two sliding operators - one that takes just the window size and another that takes window size and the increment to be applied.

.Creating a sliding view over a Sequence
====
[source,java]
----
SequenceM.of(1, 2, 3, 4, 5, 6)
         .sliding(2)
         .toList();

//List[[1,2],[2,3],[3,4],[4,5],[5,6]]
----
====
.A sliding view with StreamUtils and an increment
====
[source,java]
----
import static com.aol.cyclops.streams.StreamUtils.sliding;

List<List> list = sliding(Stream.of(1, 2, 3, 4, 5, 6),3, 2)
                        .collect(Collectors.toList());

//[[1, 2, 3], [3, 4, 5], [5, 6]]
----
====

==== Batch / Window by size

Batch / Window by size allows elements to be grouped as they flow through the Stream into Lists or Streamables of the specified size.

.Batch by size example
====
[source,java]
----
SequenceM.of(1,2,3,4,5, 6)
                            .map(n-> n==6? sleep(1) : n)
                            .batchBySize(4)
                            .toList()
//List[[1,2,3,4],[5,6]]
----
====
.Batch by size video
====
The video shows batching by size on simple-react's LazyFutureStream which is a parellel implementation of SequenceM

video::OH89bHb5yzo[youtube]
====

==== Batch / Window by time

Batch / Window by time group elements into either a List (Batch) or Streamable (Window) based on the time bucket they pass through the Stream.

.Batch by time example
====
[source,java]
----
SequenceM.of(1,2,3,4,5, 6)
         .map(n-> n==6? sleep(1) : n)
         .windowByTime(10,TimeUnit.MICROSECONDS)
         
//Streamable[[1,2,3,4,5],[6]]
----
====
.Batch by time video
====
The video shows batching by time on simple-react's LazyFutureStream which is a parellel implementation of SequenceM

video::yW7EpF4HVv4[youtube]
====


[TIP]
====
The idea of batching elements into time buckets might seem absurd if you are used to creating Java 8 Streams from already populated collections. This is can be really useful if you use cyclops-streams in conjunction with simple-react, you can connect Streams to collections that are populated asynchronously, for example on recieving a web request an async Queue could be populated that has a processing SequenceM attached. 
====

==== Batch / Window by size and time

Much like batchBySize groups elements into Lists based on the specified list size, and windowBySize organises streaming elements into Streamables by time bucket- batchBySizeAndTime / windowBySizeAndTime populates Lists (or Streamables) based on which ever criteria is met first. Should the max size be reached the List / Streamable is ready to move down stream, should the max time elaspe - ditto.

.Window by size and time example
====
[source,java]
----
SequenceM.generate(this::loadData)
         .map(this::process)
         .windowByTSizeAndTime(3,1,TimeUnit.SECONDS)
 
//4th item takes >1 second        
//Streamable[[res1,res2,res3],[res4]]
----
====

==== Batch / Window by state

Stateful batching and windowing allows the user to define a BiPredicate that recieves both the current element moving through the Stream and the Streamable from the previous window / batch. Returning true keeps the window / batch open, returning false closes it.

.Window Statefully example
====
[source,java]
----
SequenceM.of(1,2,3,4,5,6)
                .windowStatefullyWhile((s,i)->s.toList().contains(4) ? true : false)
                .toList()
//streamable[1], streamable[2], streamable[3],streamable[4], streamable[5, 6]
----
====

==== Batch / Window while a predicate holds

Batching or Windowing while allows users to keep the window / batch open as long as the predicate holds true.

.Batch while example
====
[source,java]
----
SequenceM.of(1,2,3,4,5,6)
                .batchWhile(i->i%3!=0)
                .toList()

//[1,2,3],[4,5,6]
----
====

==== Batch / Window until a predicate holds

Batching or Windowing while allows users to keep the window / batch open until the predicate holds true.
.Batch until example
====
[source,java]
----
SequenceM.of(1,2,3,4,5,6)
                .batchUntil(i->i%3==0,()->new ArrayList<>())
                .toList().size()
//[1,2,3],[4,5,6]
----
====

=== Stream manipulation
Cyclops offers many functions for manipulating Streams such as deleteBetween, insertAt and more

==== Prepending to a Stream

.Prepending
====
[source,java]
----
import static com.aol.cyclops.streams.StreamUtils.prepend;

List<String> result =   prepend(Stream.of(1,2,3),100,200,300)
                                 .map(it ->it+"!!")
                                 .collect(Collectors.toList());

List<String> result =   SequenceM.of(1,2,3)
                                 .prependStream(SequenceM.of(100,200,300))
                                 .map(it ->it+"!!")
                                 .toList();

//["100!!","200!!","300!!","1!!","2!!","3!!"] 
----
====
==== Appending to a Stream
.Appending
====
[source,java]
----
List<String> result =   SequenceM.of(1,2,3)
                                 .append(100,200,300)
                                 .map(it ->it+"!!")
                                 .toList();
import static com.aol.cyclops.streams.StreamUtils.appendStream;

List<String> result =   appendStream(Stream.of(1,2,3),SequenceM.of(100,200,300))
                                        .map(it ->it+"!!")
                                        .collect(Collectors.toList());

//["1!!","2!!","3!!","100!!","200!!","300!!"] 
----

====
==== Inserting at an index

.Inserting at index
====
[source,java]
----
List<String> result =   SequenceM.of(1,2,3).insertAt(1,100,200,300)
                .map(it ->it+"!!").collect(Collectors.toList());

import static com.aol.cyclops.streams.StreamUtils.insertStreamAt;

List<String> result =   insertStreamAt(Strean.of(1,2,3),1,Stream.of(100,200,300))
                                     .map(it ->it+"!!")
                                     .collect(Collectors.toList());
                                     
//["1!!","100!!","200!!","300!!","2!!","3!!"]
----
====

==== Deleting between two indices

.Deleting between two indices
====
[source,java]
----
List<String> result =   SequenceM.of(1,2,3,4,5,6)
                                 .deleteBetween(2,4)
                                 .map(it ->it+"!!")
                                 .toList();

import static com.aol.cyclops.streams.StreamUtils.deleteBetween;

List<String> result =   deleteBetween(Stream.of(1,2,3,4,5,6),2,4)
                                 .map(it ->it+"!!")
                                 .collect(Collectors.toList());                                 

//["1!!","2!!","5!!","6!!"]
----
====

==== SplitBy

.splitBy
====
[source,java]
----
SequenceM.of(1, 2, 3, 4, 5, 6).splitBy(i -> i % 2 != 0)
//tuple[SequenceM[1,3,5],SequenceM[2,4,6]]
----
====
==== Split At 
.splitAt
====
[source,java]
----
SequenceM.of(1, 2, 3, 4, 5, 6).splitAt(2)
//tuple[SequenceM[1,2,3],SequenceM[4,5,6]]
----
====
==== Copy a Stream

.Duplicate, triplicate and quadruplicate a Stream
====
[source,java]
----
 Tuple2<SequenceM, SequenceM> copies =  SequenceM.of(1,2,3,4,5,6).duplicateSequence();
----


[source,java]
----
 Tuple3<SequenceM, SequenceM, SequenceM> copies =SequenceM.of(1,2,3,4,5,6).triplicate();
----

[source,java]
----
 Tuple4<SequenceM, SequenceM, SequenceM,SequenceM> copies =SequenceM.of(1,2,3,4,5,6).quadruplicate();
----
====

====  Extraction

Cyclops provides many extraction operators, including many that return a Tuple containing a value and an operational Stream (such as splitAt, splitBy, headAndTail returns an object with 2 fields), and others that access a value directly (get, single) - and throw an exception if the element doesn't exist and some that return optional (elementAt, singleOptional).

.Head and Tail, get, elementAt 
====
[source,java]
----
SequenceM<String> helloWorld = SequenceM.of("hello","world","last");
HeadAndTail<String> headAndTail = helloWorld.headAndTail();
String head = headAndTail.head();
//hello

SequenceM<String> tail =  headAndTail.tail();
//[world,last]
----


Get at 0, this extracts the first value and returns a Stream of the remaining values (as a Tuple2)

[source,java]
----
SequenceM.of(1,2,3,4).get(0)
//[1],SequenceM[2,3,4]

----

Get at 1

[source,java]
----
SequenceM.of(1,2,3,4).get(1)
//[2],SequenceM[1,3,4]
----



ElementAt returns an optional containing the element at index (if exists) otherwise optional empty

[source,java]
----
SequenceM.of(1).elementAt(0)
//Optional[1]
----

[source,java]
----
SequenceM.of().elementAt(0).isPresent()
//false
----

====
  
  
.Head and Tail on a Stremable
====
[source,java]
----
int head = Streamable.of(1,2,3,4).head();
//1

Streamable<Integer> tail = Streamable.of(1,2,3,4).tail();
//Streamable[2,3,4]
----
====
=== Error handling


==== Recover

It is possible to recover from an exception thrown earlier in the Stream using the recover operator. It is available on SequenceM, Streamable and StreamUtils. Users can choose to recover differently by Exception type, or globally. 

[NOTE]
====
For those using simple-react, this differs from the simple-react only operator OnFail in that it does not provide the element data that failed.
====

.Global recover
====
In this example all exceptions types will be caught and recovered from.
[source,java]
----
SequenceM.of(1,2,3,4)
                    .map(u->{throw new RuntimeException();})
                    .recover(e->"hello")
                    .firstValue()
//hello
----
====

.Targeted recovery
====

In this example we only recover from IOExceptions.

[source,java]
----
SequenceM.of(1,2,3,4)
                    .map(i->i+2)
                    .map(u->throw ExceptionSoftener.throwSoftenedException( new IOException()))
                    .recover(IOException.class,e->"hello")
                    .firstValue()
//hello
----

Note the use of ExceptionSoftener

====

==== Retry

Retry allows a function to be retried. By default retry occurs up to 5 times with an exponential backoff.

[NOTE]
====
simple-react users should note that the implementation in LazyFutureStream is a significantly more advanced asynchronous retry (making use of Tomasz Nurkiewicz async retry library).
====
.Retry example
====

[source,java]
----
SequenceM.of( 1,  2, 3)
         .retry(this::remoteCall)
         .map(this::continueProcessing)

//if remote call fails, it will be retried with a backoff
----
====

LazyFutureStream in simple-react provides a parallel SequenceM implementation.

image::https://cloud.githubusercontent.com/assets/9964792/6320754/4ea4061e-bade-11e4-8692-481e0dc0e3f9.png[Retry in simple-react]

video::RaM_n6LAJVE[youtube]


=== Scheduling

Scheduling is available for SequenceM streams and via StreamUtils.



==== Cron Based Scheduling 

.SequenceM example
====
Send one element of a Stream through every second.

[source,java]
----
SequenceM.of(1,2,3,4)
     .peek(System.out::println)
     .schedule("* * * * * ?", ex)
----

This will print 1 2 3 4 With a new line per second.

We can connect to the output of this stream

[source,java]
----
HotStream connectable = SequenceM.of(1,2,3,4)
                .peek(System.out::println)
                .schedule("* * * * * ?", ex);
                

----

And further process the connected Stream, in this case only processing
one element per day via the debounce operator

[source,java]
----
SequenceM.of(1,2,3,4)
     .peek(System.out::println)
     .schedule("* * * * * ?", ex)
     .connect()
     .debounce(1,TimeUnit.DAYS)
     .peek(this::writeToDB)
     .toList()
----

====
.java.util.stream.Stream example
====

The final example again with JDK 8 via the static methods in
StreamUtils.

[source,java]
----
StreamUtils.debounce(StreamUtils.schedule(Stream.of(1,2,3,4)
                .peek(i->count.incrementAndGet())
                .peek(System.out::println)
                ,"* * * * * ?", ex)
                .connect()
                ,1,TimeUnit.DAYS)
                .peek(this::writeToDB)
                .toList()
----

====


==== Fixed Rate


.SequenceM example
====

This time we will execute the Stream every second using a Fixed Rate
delimiter

[source,java]
----
SequenceM.of(1,2,3,4)
     .peek(System.out::println)
     .scheduleFixedRate(1000, ex)
     .connect()
     .debounce(1,TimeUnit.DAYS)
     .peek(this::writeToDB)
     .toList()
----
====
.java.util.stream.Stream example
====

[source,java]
----
StreamUtils.debounce(StreamUtils.scheduleFixedRate(Stream.of(1,2,3,4)
                .peek(i->count.incrementAndGet())
                .peek(System.out::println)
                ,1000, ex)
                .connect()
                ,1,TimeUnit.DAYS)
                .peek(this::writeToDB)
                .toList()
----
====
==== Fixed Delay


.SequenceM example
====

This time we will execute the Stream every second using a Fixed Delay
delimiter

[source,java]
----
SequenceM.of(1,2,3,4)
     .peek(System.out::println)
     .scheduleFixedDelay(2000, ex) //2 secs after previous element passes through
     .connect()
     .debounce(1,TimeUnit.DAYS)
     .peek(this::writeToDB)
     .toList()
     
     
----
====
.java.util.stream.Stream example
====

[source,java]
----
StreamUtils.debounce(StreamUtils.scheduleFixedDelay(Stream.of(1,2,3,4)
                .peek(System.out::println)
                ,2000, ex)
                .connect()
                ,1,TimeUnit.DAYS)
                .peek(this::writeToDB)
                .toList()
----
====


=== Time based operators

Cyclops provides a number of time based operators including - onePer, xPer, jitter, debounce, timestamp & elapsed.

==== Jitter

Jitter introduces a jitter into the processing of each element, a random delay up to the max threshold specified by the user.
.jitter operator
====
[source,java]
----
SequenceM.fromIntStream(IntStream.range(0, 1000))
                .map(it -> System.currentTimeMillis())
                .jitter(10_000l)
                .forEach(System.out::println);

//random wait up to 10 seconds between each value being printed
----
====
.jitter in simple-react
====
simple-react's LazyFutureStream is a parellel implementation of SequenceM

video::v=iaKqVcEweYk[youtube]
====

==== Fixed Delay Operator

Not to be confused with scheduling fixed delay, the fixed delay operator waits a specified amount of time before processing the next element, but does not require a ScheduledExecutorService and does not create a HotStream, the per element delay is implemented on the Stream's executing thread when a terminal operation is invoked.

.fixed delay operator
====
[source,java]
----
SequenceM.fromIntStream(IntStream.range(0, 1000))
                .fixedDelay(1l, TimeUnit.MICROSECONDS)
                                .forEach(System.out::println)

//wait 1 second between each value being printed
----
====

.fixed delay in simple-react
====
simple-react's LazyFutureStream is a parellel implementation of SequenceM

video::v=ulYoM8kGiQk[youtube]
====

==== onePer operator

onePer ensures that only one element is emitted per time period, data is not lost, but rather queued and will be emitted when the next time gate opens. For an operator that drops data see debounce.

.onePer operator
====
[source,java]
----
SequenceM.iterate(0, it -> it + 1)
                .limit(100)
                .onePer(1, TimeUnit.MICROSECONDS)
                .map(seconds -> "hello!")
                .peek(System.out::println)
                .toList();

//one value emitted per second
----
.onePer in simple-react
====
simple-react's LazyFutureStream is a parellel implementation of SequenceM

video::v=cSYANZCllTI[youtube]
====
====
[TIP]
====
The xPer operator works in a similar fashion but allows only a specified number of elements through per time period. The elements will be emitted as soon as they are available, which may cause the emissions to bunch at the start of the time period.
====

==== Timestamp

The timestamp operator maps the elements in the Stream into a http://www.jooq.org/products/jOO%CE%BB/javadoc/0.9.9/org/jooq/lambda/tuple/Tuple2.html[Tuple2] containing the element and the timestamp at which it past through the timestamp operator.
.timestamp operator
====
[source,java]
----
SequenceM.of(1,2,3,4,5)
          .timestamp()

//[1,timestampInMillis],[2,timestampInMillis],[3,timestampInMillis] etc
----
====

==== Elapsed 
The elasped operator maps the elements in the Stream into a http://www.jooq.org/products/jOO%CE%BB/javadoc/0.9.9/org/jooq/lambda/tuple/Tuple2.html[Tuple2] containing the element and the elapsed time between each emission

.elapsed operator
====
[source,java]
----
SequenceM.of(1,2,3,4,5).elapsed().noneMatch(t->t.v2<0)
----
====

=== Zipping

Zipping Streams involves merging elements from multiple Streams into a single Stream of the same number of elements as the smallest Stream to be zipped.
[TIP]
====
If you are zipping Streams of unequal length and don't want to lose elements, use zip in conjunction with concat, cycle and limitUntil to cycle a series of end marker elements at the end of each Stream.
====

Zipping is available for SequenceM, Streamable and JDK Streams via StreamUtils.

==== Zip two Streams

The zip method zips two Streams and returns a SequenceM (or Stream) contain a Stream of Tuple2 elements where one element in the tuple comes from one Stream and the other from the other.
.zipping two Streams
====
[source,java]
----
SequenceM.of(1,2,3,4,5,6)
         .zip(SequenceMof(100,200,300,400))
         .toList();

//[(1, 100), (2, 200), (3, 300), (4, 400)]
----
====
.zipping two Streams in simple-react
====
simple-react's LazyFutureStream is a parellel implementation of SequenceM

video::v=Es1Y5bvml7g[youtube]
====

[NOTE]
====
The zip methods inherited from jOOλ that SequenceM overrides only accept Seq implementations (which SequenceM extends), if you want to use a JDK 8 Stream or BaseStream see the zipStream methods instead.
====

==== Zipping with a custom zipper

A number of the cyclops zip operators allow a custom zipper to be supplied (typically a BiFunction that allows users to determine how the Streams should be merged).

.zipping with a custom zipper
====
[source,java]
----
Stream<List<Integer>> zipped = StreamUtils.zipSequence(Stream.of(1,2,3)
						,SequenceM.of(2,3,4), 
							(a,b) -> Arrays.asList(a,b));
		
		
//Stream[List[1,2],List[2,3],List[3,4]]		
----
====
==== Zip three Streams

.zipping three Streams
====
[source,java]
----
SequenceM.of(1,2,3,4,5,6)
         .zip3(SequenceM.of(100,200,300,400),SequenceM.of('a','b','c'))
         .toList();
//[(1, 100, a), (2, 200, b), (3, 300, c)]
----
====

==== Zip four Streams

.zipping four Streams
====
[source,java]
----
SequenceM.of(1,2,3,4,5,6)
         .zip4(SequenceM.of(100,200,300,400),SequenceM.of('a','b','c'),SequenceM.of("hello","world"))
         .toList();
//[(1, 100, a, hello), (2, 200, b, world)]
----
====

==== Unzip

The unzip methods take a Stream containing tuples and convert them into a Tuple containing Streams.

.unzip
====
[source,java]
----
SequenceM.unzip(SequenceM.of(new Tuple2(1, "a"), new Tuple2(2, "b"), new Tuple2(3, "c")));

//Tuple2[SequenceM[1,2,3],SequenceM[a,b,c]]
----
====
==== zipWithIndex

zipWithIndex creates a Stream of Tuple2 instances, each Tuple2 contains an element from the Stream and it's 0 bound index.

.zipWithIndex
====
[source,java]
----
SequenceM.of('a','b','c')
         .zipWithIndex()

//SequenceM[Tuple['a',0],Tuple['b',1],Tuple['c',2]]
====
.zipWithIndex in simple-react
====
simple-react's LazyFutureStream is a parellel implementation of SequenceM

video::v=aTFz4lhHE-M[youtube]
====


=== Efficient reversal
=== limit / skip (take / drop) / cycle
=== Assertions
=== flatMap operators
=== scanLeft / scanRight
=== foldLeft / foldRight
=== conversions - toOptional, toCompletableFuture, toAnyM, toStreamable
=== toList, toLazyCollection, toSet
=== for-comprehensions
=== Async terminal operations 

The futureOperations operator takes an Executor, and returns the set of available asynchronous terminal operations, each of which returns a CompletableFuture. The Stream will be executed on a single thread from the supplied executor.

These methods are available via
http://static.javadoc.io/com.aol.cyclops/cyclops-sequence-api/6.2.2/com/aol/cyclops/sequence/SequenceM.html[SequenceM]
or to plain JDK 8 Streams via
http://static.javadoc.io/com.aol.cyclops/cyclops-streams/6.2.2/com/aol/cyclops/streams/StreamUtils.html[com.aol.cyclops.streams.StreamUtils],
for Javaslang Streams use
http://static.javadoc.io/com.aol.cyclops/cyclops-javaslang/6.2.2/com/aol/cyclops/javaslang/streams/StreamUtils.html[com.aol.cyclops.javaslang.streams.StreamUtils].

The available asynchronous terminal operations as of cylcops 7.1.0 are detailed http://static.javadoc.io/com.aol.cyclops/cyclops-sequence-api/7.1.0/com/aol/cyclops/sequence/future/FutureOperations.html[in the FutureOperations javadoc]

[[futureoperations]]
FutureOperations
----------------

Terminal operations can now all be called asynchronously e.g.

[source,java]
----
        CompletableFuture size = SequenceM.of(1,2,3,4)
                                                          .futureOperations(exec)
                                                          .count();
----

Available operations

* public CompletableFuture<List<T>> toList()

Asynchronously perform a mutable reduction to a JDK List

[source,java]
----
 CompletableFuture<List<Data>> myList = SequenceM.of(1,2,3,4)
                                                    .map(this::loadFromDb)
                                                       .futureOperations(getExecutor())

                                                    .toList();
----

* public CompletableFuture<Set<T>> toSet()

Asynchronously perform a mutable reduction to a JDK Set

[source,java]
----
CompletableFuture<Set<Data>> myList = SequenceM.of(1,2,3,4)
                                                            .map(this::loadFromDb)
                                                            .futureOperations(getExecutor())
                                                            .toSet();
----

* public <U extends Comparable<U>> CompletableFuture<Optional<T>>
minBy(Function<T, U> function) Asynchronously capture the minimum value
in this stream using the provided function
+
[source,java]
----
CompletableFuture<Optional> min =  SequenceM.of(1, 2, 3, 4, 5, 6)
                                                                  .futureOperations(exec)    
                                                                  .minBy(t -> Math.abs(t - 5));
//min CompletableFuture[Optional[5]]  //5-5 =0

* public <U extends Comparable<U>> CompletableFuture<Optional<T>>
maxBy(Function<T, U> function) Asynchronously capture the maximum value
in this stream using the provided function

CompletableFuture<Optional> max =  SequenceM.of(1, 2, 3, 4, 5, 6)
                                                                  .futureOperations(exec)            
                                                                  .maxBy(t -> Math.abs(t - 5));
//min CompletableFuture[Optional[1]]  //Math.abs(1-5) =4

* public <R, A> CompletableFuture<R> collect(Collector<? super T, A, R>
collector) Asynchronously perform a Stream collection ```java
CompletableFuture> list = SequenceM.of(1,2,3,4,5)
.futureOperations(exec) .collect(Collectors.toList());

//CompletableFuture[1,2,3,4,5] 
----


=== simple-react
