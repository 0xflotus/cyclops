package com.aol.cyclops.rx;

import java.util.function.BiFunction;
import java.util.function.Function;

import org.reactivestreams.Publisher;

import com.aol.cyclops.control.AnyM;
import com.aol.cyclops.control.For;
import com.aol.cyclops.control.ReactiveSeq;
import com.aol.cyclops.types.anyM.AnyMSeq;
import com.aol.cyclops.util.function.QuadFunction;
import com.aol.cyclops.util.function.TriFunction;

import lombok.experimental.UtilityClass;
import rx.Observable;
import rx.RxReactiveStreams;

/**
 * Companion class for working with RxJava Observable types
 * 
 * @author johnmcclean
 *
 */
@UtilityClass
public class Observables {
    /**
     * Convert an Observable to a reactive-streams Publisher
     * 
     * @param observable To convert
     * @return reactive-streams Publisher
     */
    public static <T> Publisher<T> publisher(Observable<T> observable) {
        return RxReactiveStreams.toPublisher(observable);
    }

    /**
     * Convert an Observable to a cyclops-react ReactiveSeq
     * 
     * @param observable To conver
     * @return ReactiveSeq
     */
    public static <T> ReactiveSeq<T> reactiveSeq(Observable<T> observable) {
        return ReactiveSeq.fromPublisher(publisher(observable));
    }

    /**
     * Convert a Publisher to an observable
     * 
     * @param publisher To convert
     * @return Observable
     */
    public static <T> Observable<T> observable(Publisher<T> publisher) {
        return RxReactiveStreams.toObservable(publisher);
    }
    /**
     * Construct an AnyM type from an Observable. This allows the Observable to be manipulated according to a standard interface
     * along with a vast array of other Java Monad implementations
     * 
     * <pre>
     * {@code 
     *    
     *    AnyMSeq<Integer> obs = Observables.anyM(Observable.just(1,2,3));
     *    AnyMSeq<Integer> transformedObs = myGenericOperation(obs);
     *    
     *    public AnyMSeq<Integer> myGenericOperation(AnyMSeq<Integer> monad);
     * }
     * </pre>
     * 
     * @param obs Observable to wrap inside an AnyM
     * @return AnyMSeq wrapping an Observable
     */
    public static <T> AnyMSeq<T> anyM(Observable<T> obs) {
        return AnyM.ofSeq(obs);
    }
    /**
     * Perform a For Comprehension over a Observable, accepting 3 generating functions. 
     * This results in a four level nested internal iteration over the provided Observables.
     * 
     *  <pre>
      * {@code
      *    
      *   import static com.aol.cyclops.rx.Observables.forEach4;
      *    
          forEach4(Observable.range(1,10), 
                  a-> Observable.range(0,10),
                  (a,b) -> Observable.range(a,b),
                  (a,b,c) -> Observable.range(a,c),
                  Tuple::tuple)
     * 
     * }
     * </pre>
     * 
     * @param value1 top level Observable
     * @param value2 Nested Observable
     * @param value3 Nested Observable
     * @param value4 Nested Observable
     * @param yieldingFunction  Generates a result per combination
     * @return Observable with an element per combination of nested Observables generated by the yielding function
     */
    public static <T1, T2, T3, R1, R2, R3, R> Observable<R> forEach4(Observable<? extends T1> value1,
            Function<? super T1, ? extends Observable<R1>> value2,
            BiFunction<? super T1, ? super R1, ? extends Observable<R2>> value3,
            TriFunction<? super T1, ? super R1, ? super R2, ? extends Observable<R3>> value4,
            QuadFunction<? super T1, ? super R1, ? super R2, ? super R3, ? extends R> yieldingFunction) {
       
        return AnyM.ofSeq(For.anyM(anyM(value1))
                             .anyM(a -> anyM(value2.apply(a)))
                             .anyM(a -> b -> anyM(value3.apply(a, b)))
                             .anyM(a -> b -> c -> anyM(value4.apply(a, b, c)))
                             .yield4(yieldingFunction)
                             .unwrap())
                   .unwrap();

    }
    /**
     * Perform a For Comprehension over a Observable, accepting 3 generating functions. 
     * This results in a four level nested internal iteration over the provided Observables. 
     * <pre>
     * {@code
     * 
     *  import static com.aol.cyclops.rx.Observables.forEach3;
     *   
     *  forEach3(Observable.range(1,10), 
                            a-> Observable.range(0,10),
                            (a,b) -> Observable.range(a,b),
                            (a,b,c) ->  Observable.range(a,c),
                            (a,b,c,d) -> a+b+c+d <100,
                            Tuple::tuple);
     * 
     * }
     * </pre>
     * 
     * @param value1 top level Observable
     * @param value2 Nested Observable
     * @param value3 Nested Observable
     * @param value4 Nested Observable
     * @param filterFunction A filtering function, keeps values where the predicate holds
     * @param yieldingFunction Generates a result per combination
     * @return Observable with an element per combination of nested Observables generated by the yielding function
     */
    public static <T1, T2, T3, R1, R2, R3, R> Observable<R> forEach3(Observable<? extends T1> value1,
            Function<? super T1, ? extends Observable<R1>> value2,
            BiFunction<? super T1, ? super R1, ? extends Observable<R2>> value3,
            TriFunction<? super T1, ? super R1, ? super R2, ? extends Observable<R3>> value4,
            QuadFunction<? super T1, ? super R1, ? super R2, ? super R3, Boolean> filterFunction,
            QuadFunction<? super T1, ? super R1, ? super R2, ? super R3, ? extends R> yieldingFunction) {

        return AnyM.ofSeq(For.anyM(anyM(value1))
                             .anyM(a -> anyM(value2.apply(a)))
                             .anyM(a -> b -> anyM(value3.apply(a, b)))
                             .anyM(a -> b -> c -> anyM(value4.apply(a, b, c)))
                             .filter(a -> b -> c -> d -> filterFunction.apply(a, b, c, d))
                             .yield4(yieldingFunction)
                             .unwrap())
                   .unwrap();

    }
    /**
     * Perform a For Comprehension over a Observable, accepting 2 generating functions. 
     * This results in a three level nested internal iteration over the provided Observables.
     * 
     *  <pre>
      * {@code
      *    
      *   import static com.aol.cyclops.rx.Observables.forEach3;
      *    
          forEach3(Observable.range(1,10), 
                  a-> Observable.range(0,10),
                  (a,b) -> Observable.range(a,b),
                  Tuple::tuple)
     * 
     * }
     * </pre>
     * 
     * @param value1 top level Observable
     * @param value2 Nested Observable
     * @param value3 Nested Observable
     * @param yieldingFunction  Generates a result per combination
     * @return Observable with an element per combination of nested Observables generated by the yielding function
     */
    public static <T1, T2, R1, R2, R> Observable<R> forEach3(Observable<? extends T1> value1,
            Function<? super T1, ? extends Observable<R1>> value2,
            BiFunction<? super T1, ? super R1, ? extends Observable<R2>> value3,
            TriFunction<? super T1, ? super R1, ? super R2, ? extends R> yieldingFunction) {

        return AnyM.ofSeq(For.anyM(anyM(value1))
                             .anyM(a -> anyM(value2.apply(a)))
                             .anyM(a -> b -> anyM(value3.apply(a, b)))
                             .yield3(yieldingFunction)
                             .unwrap())
                   .unwrap();

    }
    /**
     * Perform a For Comprehension over a Observable, accepting 2 generating functions. 
     * This results in a three level nested internal iteration over the provided Observables. 
     * <pre>
     * {@code
     * 
     *  import static com.aol.cyclops.rx.Observables.forEach3;
     *   
     *  forEach3(Observable.range(1,10), 
                            a-> Observable.range(0,10),
                            (a,b) -> Observable.range(a,b),
                            (a,b,c,d) -> a+b+c+d <100,
                            Tuple::tuple);
     * 
     * }
     * </pre>
     * 
     * @param value1 top level Observable
     * @param value2 Nested Observable
     * @param value3 Nested Observable
     * @param filterFunction A filtering function, keeps values where the predicate holds
     * @param yieldingFunction Generates a result per combination
     * @return Observable with an element per combination of nested Observables generated by the yielding function
     */
    public static <T1, T2, R1, R2, R> Observable<R> forEach3(Observable<? extends T1> value1,
            Function<? super T1, ? extends Observable<R1>> value2,
            BiFunction<? super T1, ? super R1, ? extends Observable<R2>> value3,
            TriFunction<? super T1, ? super R1, ? super R2, Boolean> filterFunction,
            TriFunction<? super T1, ? super R1, ? super R2, ? extends R> yieldingFunction) {

        return AnyM.ofSeq(For.anyM(anyM(value1))
                             .anyM(a -> anyM(value2.apply(a)))
                             .anyM(a -> b -> anyM(value3.apply(a, b)))
                             .filter(a -> b -> c -> filterFunction.apply(a, b, c))
                             .yield3(yieldingFunction)
                             .unwrap())
                   .unwrap();

    }
    /**
     * Perform a For Comprehension over a Observable, accepting a generating function. 
     * This results in a two level nested internal iteration over the provided Observables.
     * 
     *  <pre>
      * {@code
      *    
      *   import static com.aol.cyclops.rx.Observables.forEach;
      *    
          forEach(Observable.range(1,10), 
                  a-> Observable.range(0,10),
                  Tuple::tuple)
     * 
     * }
     * </pre>
     * 
     * @param value1 top level Observable
     * @param value2 Nested Observable
     * @param yieldingFunction  Generates a result per combination
     * @return Observable with an element per combination of nested Observables generated by the yielding function
     */
    public static <T, R1, R> Observable<R> forEach(Observable<? extends T> value1,
            Function<? super T, Observable<R1>> value2,
            BiFunction<? super T, ? super R1, ? extends R> yieldingFunction) {

        return AnyM.ofSeq(For.anyM(anyM(value1))
                             .anyM(a -> anyM(value2.apply(a)))
                             .yield2(yieldingFunction)
                             .unwrap())
                   .unwrap();

    }
    /**
     * Perform a For Comprehension over a Observable, accepting a generating function. 
     * This results in a two level nested internal iteration over the provided Observables. 
     * <pre>
     * {@code
     * 
     *  import static com.aol.cyclops.rx.Observables.forEach;
     *   
     *  forEach(Observable.range(1,10), 
                            a-> Observable.range(0,10),
                            (a,b,c,d) -> a+b+c+d <100,
                            Tuple::tuple);
     * 
     * }
     * </pre>
     * 
     * @param value1 top level Observable
     * @param filterFunction A filtering function, keeps values where the predicate holds
     * @param yieldingFunction Generates a result per combination
     * @return Observable with an element per combination of nested Observables generated by the yielding function
     */
    public static <T, R1, R> Observable<R> forEach(Observable<? extends T> value1,
            Function<? super T, ? extends Observable<R1>> value2,
            BiFunction<? super T, ? super R1, Boolean> filterFunction,
            BiFunction<? super T, ? super R1, ? extends R> yieldingFunction) {

        return AnyM.ofSeq(For.anyM(anyM(value1))
                             .anyM(a -> anyM(value2.apply(a)))
                             .filter(a -> b -> filterFunction.apply(a, b))
                             .yield2(yieldingFunction)
                             .unwrap())
                   .unwrap();

    }
}
