== Working with Streams

Cyclops provides a lot of helpful classes and utilities to make working with streams of data a breeze. They are 

* StreamUtils : a large collection of static methods for manipulating JDK 8 Streams
* Streamable : an interface that represents a Stream that can replayed and has a large number of available Stream operations in it's own right
* SequenceM : an advanced sequential stream interface that extends that extends
java.util.stream.Stream<T>, org.jooq.lambda.Seq<T>, java.lang.Iterable<T>, org.reactivestreams.Publisher<T> and adds additional operators.

StreamUtils, Streamable and SequenceM share many operators, in general though SequenceM has the larest range of operators.

=== Introduction to StreamUtils

StreamUtils provides a large range of additional operators for standard Java 8 Streams, these include operators for batching & windowing, error handling and retrying, scheduling, asyncrhonous execution, zipping, controlling emissions by time, appending, deleting and rearranging Streams and more!

.Using StreamUtils with a standard Java Stream
====
In this example we will delete between element 2 and element 4
[source,java]
----
List<String> result = StreamUtils.deleteBetween(Stream.of(1,2,3,4,5,6),2,4)
                                .map(it ->it+"!!")
                                .collect(Collectors.toList());
                                
//"1!!","2!!","5!!","6!!"
----

====
[NOTE]
====
There is an equivalent StreamUtils class for Javaslang Streams.
====


=== Introduction to Streamable

Streamable is a class that represents something that can be Streamed
repeatedly, Streamable also has a large number of operators viewable via http://static.javadoc.io/com.aol.cyclops/cyclops-sequence-api/7.1.0/com/aol/cyclops/sequence/streamable/Streamable.html[javadoc]. 



Streamables can also be constructed lazily from Streams, or even in a
similar manner to Streams. E.g.

.Creating a Streamable
====
[source,java]
----
Streamable.fromStream(Stream.of(1,2,3));
Streamable.of(1,2,3);
Streamable.generate(()->"hello world"));
SequenceM.of(1,2,3).toStreamable();
----
====

And then converted to a Stream, SequenceM or even manipulated directly like a Stream

.Using a Streamable
====
[source,java]
----
SequenceM<Integer> seq = streamable.sequenceM();
Stream<Integer> stream = streable.stream();

//or even treat the streamable like a stream
Streamable<Integer> initial = Streamable.of(1,2,3);
Streamable<String> nextStage = initial.map(i->"hello"+i);
----
====

[IMPORTANT]
====
Streamable works by lazily constructing an intermediate collection that captures
the values that pass through each phase of the Stream, and as such is
not suitable for infinite or very large Streams. A Streamable can be
converted to a standard non-caching Stream at any stage, however, and
that should be the approach for any stages where you do not wish to
cache the data traveleling through. Streamable#toSequenceM() converts to
a non-caching Stream that also has a SequenceM#toStreamable() operator,
so switching between caching and non-caching contexts is
straightforward.
====

=== Introduction to SequenceM

SequenceM is a sequential Stream, it can be created in the same manner as standard JDK streams, but offers a large number of powerful additional operators.

.Creating a SequenceM
====
[source,java]
----
SequenceM.fromStream(Stream.of(1,2,3));
SequenceM.fromList(Arrays.list(1,2,3));
SequenceM.of(1,2,3);
SequenceM.generate(()->"hello world"));
----
====
[source,java]

=== HotStreams

[NOTE]
====
HotStreams are streams that are actively flowing. They can be created via the hotstream method on SequenceM or in StreamUtils. They execute on a single thread on a provided executor.
====
HotStreams are available for both SequenceM and standard JDK Streams via StreamUtils.

.Creating a HotStream
====

```java
Executor exec = Executors.newFixedThreadPool(1);
SequenceM.of(1,2,3)
	 .peek(v->v+1)
	 .peek(System.out::println)
	 .hotStream(exec);
```

In this example the Stream will start processing immediately on exec, and we will see 

2

3

4

printed out to the console.

For a JDK Stream we could rewrite the code above to

```java
Executor exec = Executors.newFixedThreadPool(1);
StreamUtils.hotStream(Stream.of(1,2,3)
	 .peek(v->v+1)
	 .peek(System.out::println)
	 ,exec);
```

====
==== Connecting to a HotStream

Once a HotStream has been created, users can connect to it via the connect operator. This returns another Stream that recieves values from the HotSteam. By default the connected Stream will be a standard 'cold' Stream. That is, the values will begin to accumulate in the transfer queue for the new Stream until a terminal operation is invoked for that Stream.

Multiple Streams can connect to a single HotStream.


.Connecting to a HotStream
====
[source,java]
----
In the example below 5,000 entries will be written out on the HotStreams executing thread, and 100 of those will also be written out on the current thread.
  
SequenceM.range(0,Integer.MAX_VALUE)
                    .limit(5000)
                    .peek(System.out::println)
                    .hotStream(exec)
                    .connect()
                    .limit(100)
                    .forEach(next->System.out.println("Current thread : " + next);
----
====
===== Data transfer between Streams

HotStreams use a (configurable) transfer queue to transfer data to client Streams.

image:https://cloud.githubusercontent.com/assets/9964792/12211387/7eee02ea-b658-11e5-8605-4e29116bc0f7.png[]

When the connect method is called a new Queue is created (by default an Agrona OneToOneConcurrentArrayQueue if non is provided by the user).

==== Back pressure
When two Streams have been joined it is possible that the producting Stream may produce data at a rate faster than the consuming queue can handle. Future versions of cyclops will offer tighter integration with simple-react, which has a number of strategies for dealing with scenario - but for now it is possible for the consuming Stream to signal back pressure by making use of a blocking queue as the transfer queue between the HotStream and the connected Stream.

[WARNING]
====
The default transfer queue used by the connect method on a HotStream is an Agrona wait-free, bounded OneToOneConcurrentArrayQueue. If this queue fills up due to a producer out performing the consumer then an illegal state exception will be thrown.
====
.Applying Back Pressure
====
----
In the example below 5,000 entries will be written out on the HotStreams executing thread, the consuming thread will only emit one per second. This will cause the transfer queue to fill up, and the SequenceM generating the HotStream will crash.
  
SequenceM.range(0,Integer.MAX_VALUE)
                    .limit(5000)
                    .peek(System.out::println)
                    .hotStream(exec)
                    .connect()
                    .onePer(1,TimeUnit.SECONDS)
                    .forEach(next->System.out.println("Current thread : " + next);
                    
                    
Instead we connect and use a BlockingStream as a transfer queue, the producing Stream will ultimately be slowed to the same rate as the consuming Stream. 

SequenceM.range(0,Integer.MAX_VALUE)
                    .limit(5000)
                    .peek(System.out::println)
                    .hotStream(exec)
                    .connect(new BlockingQueue(400))
                    .onePer(1,TimeUnit.SECONDS)
                    .forEach(next->System.out.println("Current thread : " + next);
----
====
=== reactive-streams
reactive-streams is an api for advanced inter-stream operability. Cyclops, when simple-react is added to the class path can provide both a reactive-streams publisher and subscriber.
==== Creating a Subscriber

SequenceM has a static subscriber method that returns a Cyclops reactive-streams Subscriber. That is a class that can subscribe to any reactive-streams publisher (e.g. an RxJava Observable, Pivotal REACTOR Stream, akka-stream etc).

CyclopsSubscriber has a single method sequenceM() that returns a SequenceM instance (remember that SequenceM extenads java.util.stream.Stream - so this also a standard, sequential Java 8 Stream).

.Creating a reactive-streams Subscriber
====
[source,java]
----
CyclopsSubscriber sub = SequenceM.subscriber();
sub.sequenceM().toList();

//[]

In this example our subscriber will be empty, as it has not attached to a publisher, so our generated List will also be empty.
----
====
SequenceM implements reactive-streams Publisher interface, and as such has the reactive-streams api publish method.

.Connecting a Subscriber to a Publisher
====
[source,java]
----
CyclopsSubscriber sub = SequenceM.subscriber();
SequenceM.of(1,2,3,4).publish(sub);
sub.sequenceM().toList();

//[1,2,3,4]

In this example our subscriber has connected to a publisher that will send the values 1,2,3,4 in sequence, on request.
----
====
=== Batching, Windowing and Sliding views

Cyclops provides a number of different batching and windowing operations, none of which terminate / fully consume the Stream (i.e. they are compatible with infinitely large Streams). The *Sliding* operator creates a sliding view whereas both batch & window operators return batches of elements and differ only by return type (batch - returns a List, window - returns a Streamable).

[NOTE]
====
jOOλ 0.9.9 provides a large range of windowing functions inspired by SQL windowing operations. The api and, crucially, behaviour is significantly different to the windowing functions in Cyclops (the jOOλ windowing functions consume the Stream) - as result the name of the cyclops windowing functions may change in future releases to disambiguate.
====

The current Batching / Windowing operations in cyclops are inspired by Reactive eXtensions rather than SQL. Like in Reactive eXtensions Batching (or Buffering) differs from Windowing only in terms of the supplied parameter type - a List for Batching and a Streamable for Windowing.

https://medium.com/@johnmcclean/reactive-programming-with-java-8-and-simple-react-batching-and-chunking-ecac62ce8bec#.ydm0n1jdc[Also see simple-react tutorial on batching]

* Sliding

Sliding produces a sliding view over a Stream, there are two sliding operators - one that takes just the window size and another that takes window size and the increment to be applied.

.Creating a sliding view over a Sequence
====
[source,java]
----
SequenceM.of(1, 2, 3, 4, 5, 6)
         .sliding(2)
         .toList();

//List[[1,2],[2,3],[3,4],[4,5],[5,6]]
----
====
.A sliding view with StreamUtils and an increment
====
[source,java]
----
import static com.aol.cyclops.streams.StreamUtils.sliding;

List<List> list = sliding(Stream.of(1, 2, 3, 4, 5, 6),3, 2)
                        .collect(Collectors.toList());

//[[1, 2, 3], [3, 4, 5], [5, 6]]
----
====
* Batch / Window by size

Batch / Window by size allows elements to be grouped as they flow through the Stream into Lists or Streamables of the specified size.

.Batch by size example
====
[source,java]
----
SequenceM.of(1,2,3,4,5, 6)
                            .map(n-> n==6? sleep(1) : n)
                            .batchBySize(4)
                            .toList()
//List[[1,2,3,4],[5,6]]
----
====
.Batch by size video
====
The video shows batching by size on simple-react's LazyFutureStream which is a parellel implementation of SequenceM

video::OH89bHb5yzo[youtube]
====
* Batch / Window by time

Batch / Window by time group elements into either a List (Batch) or Streamable (Window) based on the time bucket they pass through the Stream.

.Batch by time example
====
[source,java]
----
SequenceM.of(1,2,3,4,5, 6)
         .map(n-> n==6? sleep(1) : n)
         .windowByTime(10,TimeUnit.MICROSECONDS)
         
//Streamable[[1,2,3,4,5],[6]]
----
====
.Batch by time video
====
The video shows batching by time on simple-react's LazyFutureStream which is a parellel implementation of SequenceM

video::yW7EpF4HVv4[youtube]
====


[TIP]
====
The idea of batching elements into time buckets might seem absurd if you are used to creating Java 8 Streams from already populated collections. This is can be really useful if you use cyclops-streams in conjunction with simple-react, you can connect Streams to collections that are populated asynchronously, for example on recieving a web request an async Queue could be populated that has a processing SequenceM attached. 
====
* Batch / Window by size and time

Much like batchBySize groups elements into Lists based on the specified list size, and windowBySize organises streaming elements into Streamables by time bucket- batchBySizeAndTime / windowBySizeAndTime populates Lists (or Streamables) based on which ever criteria is met first. Should the max size be reached the List / Streamable is ready to move down stream, should the max time elaspe - ditto.

.Window by size and time example
====
[source,java]
----
SequenceM.generate(this::loadData)
         .map(this::process)
         .windowByTSizeAndTime(3,1,TimeUnit.SECONDS)
 
//4th item takes >1 second        
//Streamable[[res1,res2,res3],[res4]]
----
====

* Batch / Window by state

Stateful batching and windowing allows the user to define a BiPredicate that recieves both the current element moving through the Stream and the Streamable from the previous window / batch. Returning true keeps the window / batch open, returning false closes it.

.Window Statefully example
====
[source,java]
----
SequenceM.of(1,2,3,4,5,6)
                .windowStatefullyWhile((s,i)->s.toList().contains(4) ? true : false)
                .toList()
//streamable[1], streamable[2], streamable[3],streamable[4], streamable[5, 6]
----
====
* Batch / Window while a predicate holds

Batching or Windowing while allows users to keep the window / batch open as long as the predicate holds true.

.Batch while example
====
[source,java]
----
SequenceM.of(1,2,3,4,5,6)
                .batchWhile(i->i%3!=0)
                .toList()

//[1,2,3],[4,5,6]
----
====
* Batch / Window until a predicate holds
Batching or Windowing while allows users to keep the window / batch open until the predicate holds true.
.Batch until example
====
[source,java]
----
SequenceM.of(1,2,3,4,5,6)
                .batchUntil(i->i%3==0,()->new ArrayList<>())
                .toList().size()
//[1,2,3],[4,5,6]
----
====
=== Stream manipulation
=== Stream duplication
=== Error handling
=== Scheduling


Since cyclops 7.1.0 it is possible to schedule Stream events (whereby
the next element will travel through the pipeline), using a cron
expression, fixed rate delimiter or fixed delay delimiter.

Supported Stream types are

* JDK 8 Stream
(https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html[java.util.stream.Stream])
via
http://static.javadoc.io/com.aol.cyclops/cyclops-streams/7.1.0/com/aol/cyclops/streams/StreamUtils.html[StreamUtils]
* Javaslang Stream (via cyclops-javaslang
http://static.javadoc.io/com.aol.cyclops/cyclops-javaslang/7.1.0/com/aol/cyclops/javaslang/streams/StreamUtils.html[StreamUtils])
* http://static.javadoc.io/com.aol.cyclops/cyclops-sequence-api/7.1.0/com/aol/cyclops/sequence/SequenceM.html[SequenceM]
(java.util.stream.Stream and https://github.com/jOOQ/jOOL[jOOλ]
http://www.jooq.org/products/jOO%CE%BB/javadoc/0.9.7/org/jooq/lambda/Seq.html[Seq]
extension).

[[coming-soon]]
Coming Soon
~~~~~~~~~~~

https://github.com/aol/cyclops/issues/95[SequenceM equivalent for
Javaslang Streams]

[[examples]]
Examples
~~~~~~~~

[[cron]]
Cron
^^^^

[[sequencem]]
SequenceM
+++++++++

Send one element of a Stream through every second.

[source,java]
----
SequenceM.of(1,2,3,4)
     .peek(System.out::println)
     .schedule("* * * * * ?", ex)
----

This will print 1 2 3 4 With a new line per second.

We can connect to the output of this stream

[source,java]
----
HotStream connectable = SequenceM.of(1,2,3,4)
                .peek(System.out::println)
                .schedule("* * * * * ?", ex);
                

----

And further process the connected Stream, in this case only processing
one element per day via the debounce operator

[source,java]
----
SequenceM.of(1,2,3,4)
     .peek(System.out::println)
     .schedule("* * * * * ?", ex)
     .connect()
     .debounce(1,TimeUnit.DAYS)
     .peek(this::writeToDB)
     .toList()
----

[[jdk-8]]
JDK 8
+++++

The final example again with JDK 8 via the static methods in
StreamUtils.

[source,java]
----
StreamUtils.debounce(StreamUtils.schedule(Stream.of(1,2,3,4)
                .peek(i->count.incrementAndGet())
                .peek(System.out::println)
                ,"* * * * * ?", ex)
                .connect()
                ,1,TimeUnit.DAYS)
                .peek(this::writeToDB)
                .toList()
----

[[javaslang]]
Javaslang
+++++++++

The final example again with Javaslang via the static methods in
cyclops-javaslang StreamUtils.

[source,java]
----
StreamUtils.debounce(StreamUtils.schedule(Stream.ofAll(1,2,3,4)
                .peek(System.out::println)
                ,"* * * * * ?", ex)
                .connect()
                ,1,TimeUnit.DAYS)
                .peek(this::writeToDB)
                .toList()
----

[[fixed-rate]]
Fixed Rate
^^^^^^^^^^

[[sequencem-1]]
SequenceM
+++++++++

This time we will execute the Stream every second using a Fixed Rate
delimiter

[source,java]
----
SequenceM.of(1,2,3,4)
     .peek(System.out::println)
     .scheduleFixedRate(1000, ex)
     .connect()
     .debounce(1,TimeUnit.DAYS)
     .peek(this::writeToDB)
     .toList()
----

[[jdk-8-1]]
JDK 8
+++++

[source,java]
----
StreamUtils.debounce(StreamUtils.scheduleFixedRate(Stream.of(1,2,3,4)
                .peek(i->count.incrementAndGet())
                .peek(System.out::println)
                ,1000, ex)
                .connect()
                ,1,TimeUnit.DAYS)
                .peek(this::writeToDB)
                .toList()
----

[[javaslang-1]]
Javaslang
+++++++++


=== Time based operators
=== Zipping
=== Efficient reversal
=== for-comprehensions
=== Async terminal operations 

The futureOperations operator takes an Executor, and returns the set of available asynchronous terminal operations, each of which returns a CompletableFuture. The Stream will be executed on a single thread from the supplied executor.

These methods are available via
http://static.javadoc.io/com.aol.cyclops/cyclops-sequence-api/6.2.2/com/aol/cyclops/sequence/SequenceM.html[SequenceM]
or to plain JDK 8 Streams via
http://static.javadoc.io/com.aol.cyclops/cyclops-streams/6.2.2/com/aol/cyclops/streams/StreamUtils.html[com.aol.cyclops.streams.StreamUtils],
for Javaslang Streams use
http://static.javadoc.io/com.aol.cyclops/cyclops-javaslang/6.2.2/com/aol/cyclops/javaslang/streams/StreamUtils.html[com.aol.cyclops.javaslang.streams.StreamUtils].

The available asynchronous terminal operations as of cylcops 7.1.0 are detailed http://static.javadoc.io/com.aol.cyclops/cyclops-sequence-api/7.1.0/com/aol/cyclops/sequence/future/FutureOperations.html[in the FutureOperations javadoc]

[[futureoperations]]
FutureOperations
----------------

Terminal operations can now all be called asynchronously e.g.

[source,java]
----
        CompletableFuture size = SequenceM.of(1,2,3,4)
                                                          .futureOperations(exec)
                                                          .count();
----

Available operations

* public CompletableFuture<List<T>> toList()

Asynchronously perform a mutable reduction to a JDK List

[source,java]
----
 CompletableFuture<List<Data>> myList = SequenceM.of(1,2,3,4)
                                                    .map(this::loadFromDb)
                                                       .futureOperations(getExecutor())

                                                    .toList();
----

* public CompletableFuture<Set<T>> toSet()

Asynchronously perform a mutable reduction to a JDK Set

[source,java]
----
CompletableFuture<Set<Data>> myList = SequenceM.of(1,2,3,4)
                                                            .map(this::loadFromDb)
                                                            .futureOperations(getExecutor())
                                                            .toSet();
----

* public <U extends Comparable<U>> CompletableFuture<Optional<T>>
minBy(Function<T, U> function) Asynchronously capture the minimum value
in this stream using the provided function
+
[source,java]
----
CompletableFuture<Optional> min =  SequenceM.of(1, 2, 3, 4, 5, 6)
                                                                  .futureOperations(exec)    
                                                                  .minBy(t -> Math.abs(t - 5));
//min CompletableFuture[Optional[5]]  //5-5 =0

* public <U extends Comparable<U>> CompletableFuture<Optional<T>>
maxBy(Function<T, U> function) Asynchronously capture the maximum value
in this stream using the provided function

CompletableFuture<Optional> max =  SequenceM.of(1, 2, 3, 4, 5, 6)
                                                                  .futureOperations(exec)            
                                                                  .maxBy(t -> Math.abs(t - 5));
//min CompletableFuture[Optional[1]]  //Math.abs(1-5) =4

* public <R, A> CompletableFuture<R> collect(Collector<? super T, A, R>
collector) Asynchronously perform a Stream collection ```java
CompletableFuture> list = SequenceM.of(1,2,3,4,5)
.futureOperations(exec) .collect(Collectors.toList());

//CompletableFuture[1,2,3,4,5] 
----


=== simple-react
